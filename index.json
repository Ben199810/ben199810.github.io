[{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/","section":"Bing-wei's Blog","summary":"","title":"Bing-wei's Blog","type":"page"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/k8s/","section":"Tags","summary":"","title":"k8s","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/m1/","section":"Tags","summary":"","title":"m1","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/m2/","section":"Tags","summary":"","title":"m2","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/mac/","section":"Tags","summary":"","title":"mac","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/minikube/","section":"Tags","summary":"","title":"minikube","type":"tags"},{"content":" 前言 # 最近趁著 BTS 學生教育方案入手了 macbook pro m2 版本，因此也想要在上面安裝 minikube 來練習 k8s 的操作。但在安裝的過程中，發現了一些問題，因此紀錄一下。\n問題 # 在安裝的過程中，發現目前 vitrualbox 還不支援 m1 與 m2 版本的 mac。所以找了其他的虛擬機軟體\n其中也有使用 hyperkit 來安裝的方式。但也是不行。\n解決方案 # 後來找到 Qemu 這個虛擬機軟體，這邊簡單介紹。\nQEMU 是一種模擬器，它能夠完成使用者程式模擬和系統虛擬化模擬：\n使用者程式模擬：QEMU 能夠將為一個平台編譯的二進位檔案運行在另一個不同的平台。 系統虛擬化模擬：QEMU 能夠模擬一個完整的系統虛擬機，該虛擬機有自己的虛擬CPU、晶片組、虛擬記憶體以及各種虛擬外部設備，能夠為虛擬機中運行的作業系統和應用軟體呈現出與實體電腦完全一致的硬體視圖。QEMU能夠模擬 x86、ARM、MIPS、PPC 等多個平台。 沒錯，可能有讀者發現了重點，因為 m1 與 m2 是 ARM 架構，因此可以使用 Qemu 來模擬我們所需要的 VM 環境。\n安裝 # 先安裝 Qemu\nbrew install qemu 接著設定 Qemu socket_vvmnet\nbrew install socket_vmnet brew tap homebrew/services HOMEBREW=$(which brew) \u0026amp;\u0026amp; sudo ${HOMEBREW} services start socket_vmnet 就可以啟動我們的環境啦！\nminikube start --driver qemu --network socket_vmnet 參考資料 # How to Setup Minikube on MAC M1/M2 ","date":"24 September 2023","externalUrl":null,"permalink":"/posts/minikube/install/apple/","section":"Posts","summary":"前言 # 最近趁著 BTS 學生教育方案入手了 macbook pro m2 版本，因此也想要在上面安裝 minikube 來練習 k8s 的操作。但在安裝的過程中，發現了一些問題，因此紀錄一下。\n問題 # 在安裝的過程中，發現目前 vitrualbox 還不支援 m1 與 m2 版本的 mac。所以找了其他的虛擬機軟體\n其中也有使用 hyperkit 來安裝的方式。但也是不行。\n解決方案 # 後來找到 Qemu 這個虛擬機軟體，這邊簡單介紹。","title":"minikube 安裝 for M系列晶片 Mac","type":"posts"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"22 September 2023","externalUrl":null,"permalink":"/tags/cicd/","section":"Tags","summary":"","title":"cicd","type":"tags"},{"content":"","date":"22 September 2023","externalUrl":null,"permalink":"/tags/gitlab/","section":"Tags","summary":"","title":"gitlab","type":"tags"},{"content":" 前言 # 最近因為公司有在進行 GitLab 轉移，所以要重新建構 CICD，提供比較好維護的 CI modules，讓所有的組能夠通用，達到流程簡化的目的。有開始用一些比較進階的 CICD 寫法所以透過寫筆記，提升自己的印象。\n概念 # 使用 gitlab-ci 建立的自動化流程，稱作 pipeline 中文意思是流水線。就像設定好一個生產線一樣十分有趣。 這邊已經知道了 pipeline，那由誰執行 pipeline 的流程呢？答案是 gitlab runner。當有 pipeline 觸發且需要執行時，會有 job 產生，這些 job 就會分配給 runner 去執行囉！ 基礎 CICD # 了解概念之後，就可以開始寫自己的 CICD 了！那一般的 CICD 流程是什麼呢？一般來說會有以下基本元素：\n:one: Stage\n:two: Job\n:three: Script\n可以看到下面的 yaml 是一個基礎的 pipeline 範例，可以看到有三個 stage，分別是 build、test、deploy，每個 stage 底下都有一個 job，每個 job 底下都有一個 script，這個 script 就是要執行的指令。\n範例：\nstages: - build - test - deploy build: stage: build script: # 定義 build 階段的指令 - echo \u0026#34;Building the application\u0026#34; - docker build -t $IMAGE_NAME:$TAG . test: stage: test script: # 定義 test 階段的指令 - echo \u0026#34;Running tests\u0026#34; deploy: stage: deploy script: # 定義 deploy 階段的指令 - echo \u0026#34;Deploying to production\u0026#34; # 在實際情況下，這裡可以是部署到 Kubernetes、AWS、GCP 等的相應指令 # 也可以使用 Helm 進行部署 ","date":"22 September 2023","externalUrl":null,"permalink":"/posts/gitlab/cicd/","section":"Posts","summary":"前言 # 最近因為公司有在進行 GitLab 轉移，所以要重新建構 CICD，提供比較好維護的 CI modules，讓所有的組能夠通用，達到流程簡化的目的。有開始用一些比較進階的 CICD 寫法所以透過寫筆記，提升自己的印象。\n概念 # 使用 gitlab-ci 建立的自動化流程，稱作 pipeline 中文意思是流水線。就像設定好一個生產線一樣十分有趣。 這邊已經知道了 pipeline，那由誰執行 pipeline 的流程呢？答案是 gitlab runner。當有 pipeline 觸發且需要執行時，會有 job 產生，這些 job 就會分配給 runner 去執行囉！ 基礎 CICD # 了解概念之後，就可以開始寫自己的 CICD 了！那一般的 CICD 流程是什麼呢？一般來說會有以下基本元素：","title":"GitLab CICD","type":"posts"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/tags/cni/","section":"Tags","summary":"","title":"cni","type":"tags"},{"content":" 前言 # 最近在協助公司專案轉雲端架構時，由於服務只能啟用一個 pod 提供線上服務的運作，因此也選擇使用 statefulSet 部署服務，在這過程中發現的問題。\n事件流程 # RD 同仁更新了 code 到 gitLab，並沒有順利的完成 CICD。原因是 statefulSet pod 在關閉時，停留在 terminating，雖然 k8s 有 terminationGracePeriodSeconds，但由於情況特殊。當下的 terminationGracePeriodSeconds 是 14400，長達四小時。\n因線上緊急的問題，所以針對 terminating pod 採取了 kubectl delete pod [pod name] --grace-period=0 --force。之後重新建立的 pod 就會出現以下的錯誤訊息 :backhand_index_pointing_down:\ncontainer veth name provided (eth0) already exists Google Support # 其實前陣子已經有錯誤影響到開發跟測試環境了，由於這次影響到正式環境。把案件單等級提升至 P1 並請 google 協助查找錯誤發生的原因。\n這次會發生的上述錯誤的原因，經過 google 協助主要是推測在 pod 進入關閉流程時，由於 terminationGracePeriodSeconds 設置時長有四小時，尚處於 pod 的 lifecycle 這時候，使用 kubectl delete pod --force 會導致隨然 pod 消失了，但有 container 設定殘留在 node 上，如果此時新的 pod 重新在同一顆 node 上面啟動就會造成有相同設定。\n雖然改成 deployment 可以規避，但相對的會浪費一組 IP，長久下來一樣會有問題。最重要的還是要讓 pod 結束整個 lifecycle 才不會產生後續的問題。\n","date":"17 September 2023","externalUrl":null,"permalink":"/journals/k8s/veth-name-provided-already-exists/","section":"Journals","summary":"前言 # 最近在協助公司專案轉雲端架構時，由於服務只能啟用一個 pod 提供線上服務的運作，因此也選擇使用 statefulSet 部署服務，在這過程中發現的問題。\n事件流程 # RD 同仁更新了 code 到 gitLab，並沒有順利的完成 CICD。原因是 statefulSet pod 在關閉時，停留在 terminating，雖然 k8s 有 terminationGracePeriodSeconds，但由於情況特殊。當下的 terminationGracePeriodSeconds 是 14400，長達四小時。\n因線上緊急的問題，所以針對 terminating pod 採取了 kubectl delete pod [pod name] --grace-period=0 --force。之後重新建立的 pod 就會出現以下的錯誤訊息 :backhand_index_pointing_down:","title":"container veth name provided (eth0) already exists 故障排除","type":"journals"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/journals/","section":"Journals","summary":"","title":"Journals","type":"journals"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/tags/node/","section":"Tags","summary":"","title":"node","type":"tags"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/tags/pod/","section":"Tags","summary":"","title":"pod","type":"tags"},{"content":"","date":"27 August 2023","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"docker","type":"tags"},{"content":" 前言 # docker 是將 image 俗稱映像或者鏡像檔，建立容器的模擬使用環境的技術。那要如何建立 image 呢？\n接著介紹本篇文章的重點 Dockerfile\nDockerfile # Dockfile 是一個建構 image 的腳本，基於你選擇的基底映像，開始安裝在開發環境所需要的依賴以及套件等等\u0026hellip;\n建立 image 也可以保證每個開發者在進行開發時使用的環境都相同，不會導致將程式碼推上去版控，經過打包發布才發現有相容性的問題。有效的消除了在協同開發時會遇到的衝突呢～\n下面提供簡單的 dockerfile 範例。下面的範例步驟使用引用 alpine image 當做基底，並且安裝 curl 套件。以 image 啟動 container 時，會執行 /bin/bash。 :point_right: docker run -it [image] /bin/bash\n# image 基底 FROM alpine # 安裝套件或執行的 shell RUN apk add curl CMD [\u0026#34;/bin/bash\u0026#34;] ","date":"27 August 2023","externalUrl":null,"permalink":"/posts/docker/dockerfile/","section":"Posts","summary":"前言 # docker 是將 image 俗稱映像或者鏡像檔，建立容器的模擬使用環境的技術。那要如何建立 image 呢？\n接著介紹本篇文章的重點 Dockerfile\nDockerfile # Dockfile 是一個建構 image 的腳本，基於你選擇的基底映像，開始安裝在開發環境所需要的依賴以及套件等等\u0026hellip;\n建立 image 也可以保證每個開發者在進行開發時使用的環境都相同，不會導致將程式碼推上去版控，經過打包發布才發現有相容性的問題。有效的消除了在協同開發時會遇到的衝突呢～\n下面提供簡單的 dockerfile 範例。下面的範例步驟使用引用 alpine image 當做基底，並且安裝 curl 套件。以 image 啟動 container 時，會執行 /bin/bash。 :point_right: docker run -it [image] /bin/bash","title":"Dockerfile","type":"posts"},{"content":"","date":"19 August 2023","externalUrl":null,"permalink":"/tags/ingress/","section":"Tags","summary":"","title":"ingress","type":"tags"},{"content":" 前言 # 隨著系統架構可能日益龐大，可能會使用複數的 ingress 來做進入服務的區分。以防止在 ingress 異常的時候，會影響全體的服務使用。缺點是複數的 ingress 需要使用靜態 IP。在 GCP 的服務上，每保留一組靜態 IP 服務就是增加成本。接著會介紹 ingress controller 這項服務用於管理所有的 ingress。\n上一篇文章中有提到 ingress，如果想瞭解 ingress 可以先參考或預習這篇文章。 Ingress 6 August 2023\u0026middot;1 分鐘\u0026middot; loading \u0026middot; loading k8s ingress Nginx Ingress Controller # 這篇文章要講解的 Nginx Ingress Controller 結合了 Ingress 的簡潔並支援 Nginx 相關的擴充功能，讓我們能更好的管理所有的 ingress，下面會簡單提到 nginx 以及 ingress 優點。\nNginx 介紹 # nginx 是一款高效能、耐用、且功能強大的 loadBalance 及 webServer。也擁有很高的市佔率。\n高效能的 webServer 遠勝傳統 apache server 的資源與效能 大量的模組與擴充功能 充足的安全性功能 輕量 容易水平擴展 Ingress 介紹 # 定義外部到內部的設定。\nService 連接 LoadBalance 設定 SSL/TLS 終端 虛擬主機設定 安裝 # 使用 Helm 來安裝 Ingress Controller helm upgrade --install ingress-nginx ingress-nginx \\ --repo https://kubernetes.github.io/ingress-nginx \\ --namespace ingress-nginx --create-namespace values # 使用 Helm 進行安裝，需要做調整，並想要參考有哪些值是可提供使用者調整。可以使用下列的指令輸出 values.yaml。\n或者到 Github 上閱讀整個服務的是如何運作跟建立的\nhelm show values ingress-nginx --repo https://kubernetes.github.io/ingress-nginx ","date":"19 August 2023","externalUrl":null,"permalink":"/posts/k8s/ingress-controller/","section":"Posts","summary":"前言 # 隨著系統架構可能日益龐大，可能會使用複數的 ingress 來做進入服務的區分。以防止在 ingress 異常的時候，會影響全體的服務使用。缺點是複數的 ingress 需要使用靜態 IP。在 GCP 的服務上，每保留一組靜態 IP 服務就是增加成本。接著會介紹 ingress controller 這項服務用於管理所有的 ingress。\n上一篇文章中有提到 ingress，如果想瞭解 ingress 可以先參考或預習這篇文章。 Ingress 6 August 2023\u0026middot;1 分鐘\u0026middot; loading \u0026middot; loading k8s ingress Nginx Ingress Controller # 這篇文章要講解的 Nginx Ingress Controller 結合了 Ingress 的簡潔並支援 Nginx 相關的擴充功能，讓我們能更好的管理所有的 ingress，下面會簡單提到 nginx 以及 ingress 優點。","title":"Ingress Controller 簡介","type":"posts"},{"content":" 介紹 ingress # ingress 是 k8s 給 service 提供外部訪問的 URL、SSL、路由等功能。 可以理解為 nginx 或 traefik 等的代理工具。允許透過某個 URL 進入對應的 service，且碰到某些 route 能夠 proxy pass 到其他 service。\n:star: ingress 又分成外部負載平衡、內部負載平衡。兩者在使用設定上有一些小小的不同。\n外部負載平衡 # 通常對外部的負載平衡入口，都會設置防火牆或是白名單管理但是 k8s ingress 卻不能直接實現。需要透過一些 gcp 元件功能，來設置防火牆或白名單管理。\ncloud armor # armor 的翻譯是指盔甲的意思，這是由 gcp 提供的服務，具有分散式阻斷攻擊(DDos)防護機制、網路應用程式防火牆。可以搭配 loadBalance、Cloud CDN 來強化網路安全服務。\n那麼我們要如何將 cloud armor 應用在我們 ingress 上面呢？接著看下去 :sunglasses:\n首先我們可以先找官方的使用手冊 Configuring Ingress using the default controller 接著將重點放在 backendConfig 設定上面，前面的介紹已經知道 ingress 負責依據路由規則代理轉發。文件上 backenConfig 與 service 可以耦合。使用 backendConfig 的設定。\nBackendConfig and FrontendConfig overview 詳細想知道 backendConfig 設定範例可以在文件連接內找到 :point_right: Configuring Ingress features through BackendConfig parameters 接著下面繪製一張外部負載平衡的架構圖。可以看到下圖中 114.1.46.157 的客戶端在訪問的時候被 ingress 給擋下了。\n原因是 ingress 後端 service 有耦合 backendConfig，透過 backendConfig 使用了 cloud armor。\nflowchart LR cli1(client 34.41.26.173) cli2(client 114.1.46.157) cli1 --\u003e ing cli2 --x ing subgraph k8s-cluster ing((ingress)) svc-web(web-service) svc-api(api-service) df-backend(backend-config) armor{{cloud-armor}} ing --\u003e svc-web ing --\u003e svc-api armor -.- df-backend df-backend -.-\u003e svc-web df-backend -.-\u003e svc-api end 內部負載平衡 # 講完了外部負載平衡，接著講 ingress 擔任內部負載平衡時，需要注意的事項。\nNetwork endpoint group # 什麼是 NEG ?\nNEG 是指 Network endpoint group，是一種配置。意思是指定一組後端 endpoint 或 service，借助NEG，Google Cloud 負載均衡器可以為基於 GCE 的工作負載、無服務器工作負載和容器化工作負載提供服務。可以更精細的將流量分配到負載均衡器的後端。\n使用時，對後端的 service 必須要使用 NEG，詳細想要了解可以參考 :point_right: Network endpoint groups overview ","date":"6 August 2023","externalUrl":null,"permalink":"/posts/k8s/ingress/","section":"Posts","summary":"介紹 ingress # ingress 是 k8s 給 service 提供外部訪問的 URL、SSL、路由等功能。 可以理解為 nginx 或 traefik 等的代理工具。允許透過某個 URL 進入對應的 service，且碰到某些 route 能夠 proxy pass 到其他 service。\n:star: ingress 又分成外部負載平衡、內部負載平衡。兩者在使用設定上有一些小小的不同。\n外部負載平衡 # 通常對外部的負載平衡入口，都會設置防火牆或是白名單管理但是 k8s ingress 卻不能直接實現。需要透過一些 gcp 元件功能，來設置防火牆或白名單管理。","title":"Ingress","type":"posts"},{"content":" 匯出/入映像檔 # :star: export 可以匯出 container 已變更的設定\n:star: save 單純匯出 image\n:star: 這裡要注意 export 對應 import ; save 對應 load\ndocker export [image] \u0026gt; [filename].tar docker import \u0026lt; [filname].tar docker save [image]:[tag] \u0026gt; [filname].tar docker load \u0026lt; [filname].tar 在容器裡執行應用程序 # :star: docker start、stop、restart\ndocker run [image] /bin/echo \u0026#34;Hello world\u0026#34; 與容器進行交互 # -t：終端機 -i：准許你與容器交互 -d：在背景執行 exit 或 ctrl+d：離開容器 docker run -i -t [image] /bin/bash 在容器裡查看當前系統版本信息。 # cat /proc/version 查看運行的容器 # -a：顯示所有容器 docker ps 查看容器內的標準輸出 # -f：持續查看 docker logs [container] 進入容器 # :star: 如果使用 attach 進入容器，退出時會導致容器停止\ndocker attach [container] docker exec -it [container] /bin/bash 查看 image 、 container 詳細大小。 # docker system df -v 查看容器啟動進程 # docker top [container] container 資源使用狀況 # docker stats docker-compose 針對特定容器重啟 # docker-compose up --detach --build [service_name] docker 清理技巧 # 清理 Docker 的 container，image 與 volume :star: prune操作是批量刪除類的危險操作，使用 y 確認。不想要輸入可以添加 -f，慎用!\n清除所有停止運行的容器 # docker container prune 清理所有 image # docker image prune 清理未使用的 image # docker image prune -a 清理所有無用的 volumes # docker volume prune Dcokerfile 與 Docker-compose # Day14 Dockerfile \u0026amp; Docker-Compose 對 Docker Image 做反編譯成 Dockerfile # 沒有命令直接通過 image 就能反編譯，獲得 Dockerfile\n但是我們可以使用 docker history 命令，進行反推\n--format：自定義輸出格式 --no-trunc：CREATED BY 列完整顯示 使用 history\ndocker history [image:tag] docker history [image:tag] --format \u0026#34;table {{.ID}}\\t{{.CreatedBy}}\u0026#34; --no-trunc ","date":"30 July 2023","externalUrl":null,"permalink":"/posts/docker/command/","section":"Posts","summary":"匯出/入映像檔 # :star: export 可以匯出 container 已變更的設定\n:star: save 單純匯出 image\n:star: 這裡要注意 export 對應 import ; save 對應 load\ndocker export [image] \u0026gt; [filename].tar docker import \u0026lt; [filname].tar docker save [image]:[tag] \u0026gt; [filname].","title":"Docker 指令","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]