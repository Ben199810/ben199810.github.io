[{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/","section":"bing-wei's Blog","summary":"","title":"bing-wei's Blog","type":"page"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/k8s/","section":"Tags","summary":"","title":"k8s","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/m1/","section":"Tags","summary":"","title":"m1","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/m2/","section":"Tags","summary":"","title":"m2","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/mac/","section":"Tags","summary":"","title":"mac","type":"tags"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/minikube/","section":"Tags","summary":"","title":"minikube","type":"tags"},{"content":" 介紹 # minikube 是一個輕量級的 Kubernetes 環境，主要用於本地開發和測試。它可以在本地機器上啟動一個單節點的 Kubernetes 集群，讓開發者可以快速地部署和測試應用程式。\nminikube 支援多種虛擬化技術，包括 VirtualBox、VMware、KVM、Hyper-V 等等。它可以在 Windows、macOS 和 Linux 上運行。\nQemu # Qemu 是一個開源的虛擬化軟體，可以模擬多種硬體架構，包括 x86、ARM、MIPS 等等。它可以用於虛擬化和模擬不同的作業系統和應用程式。\nQemu 的主要功能包括：\n使用者程式模擬：QEMU 能夠將為一個平台編譯的二進位檔案運行在另一個不同的平台。 系統虛擬化模擬：QEMU 能夠模擬一個完整的系統虛擬機，該虛擬機有自己的虛擬CPU、晶片組、虛擬記憶體以及各種虛擬外部設備，能夠為虛擬機中運行的作業系統和應用軟體呈現出與實體電腦完全一致的硬體視圖。QEMU能夠模擬 x86、ARM、MIPS、PPC 等多個平台。 Qemu 在 macOS 上的使用主要是為了支援 M 系列晶片（如 M1、M2）的虛擬化，因為這些晶片使用 ARM 架構，而許多傳統的虛擬化技術（如 VirtualBox）並不支援 ARM 架構。\n安裝 # 在 macOS 上安裝 minikube 和 Qemu，可以使用 Homebrew 來簡化安裝過程。 首先，確保你已經安裝了 Homebrew。如果還沒有安裝，可以參考 Homebrew 官方網站 進行安裝。\nbrew install minikube brew install qemu 接著，為了讓 minikube 使用 Qemu 作為虛擬化驅動程式，我們需要安裝 socket_vmnet。這是一個用於 macOS 的 Qemu 虛擬化網路驅動程式。\nbrew install socket_vmnet brew tap homebrew/services HOMEBREW=$(which brew) \u0026amp;\u0026amp; sudo ${HOMEBREW} services start socket_vmnet 啟動 Minikube # 在安裝完成後，可以使用以下命令啟動 minikube，並指定使用 Qemu 作為虛擬化驅動程式。\nminikube start --driver qemu --network socket_vmnet 參考資料 # How to Setup Minikube on MAC M1/M2 ","date":"24 September 2023","externalUrl":null,"permalink":"/posts/minikube/","section":"Posts","summary":"介紹 # minikube 是一個輕量級的 Kubernetes 環境，主要用於本地開發和測試。它可以在本地機器上啟動一個單節點的 Kubernetes 集群，讓開發者可以快速地部署和測試應用程式。","title":"Minikube 環境與安裝 (Mac M1/M2)","type":"posts"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 September 2023","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"22 September 2023","externalUrl":null,"permalink":"/tags/cicd/","section":"Tags","summary":"","title":"cicd","type":"tags"},{"content":"","date":"22 September 2023","externalUrl":null,"permalink":"/tags/gitlab/","section":"Tags","summary":"","title":"gitlab","type":"tags"},{"content":" 介紹 # GitLab 是一個開源的 DevOps 平台，提供了版本控制、CI/CD、代碼審查等功能。它的 CI/CD 功能可以幫助開發者自動化軟體開發流程，提高開發效率和質量。\nGitLab 的 CI/CD 功能基於 GitLab Runner，允許開發者定義自動化的工作流程，從代碼提交到部署生產環境都可以自動化完成。\nGitLab CI/CD 的配置文件是 .gitlab-ci.yml，這個文件定義了 CI/CD 的工作流程，包括各個階段（stages）、任務（jobs）和執行的腳本（scripts）。開發者可以根據自己的需求定義不同的工作流程，並且可以在不同的階段中執行不同的任務。\n基本配置 # 以下是一個簡單的 .gitlab-ci.yml 配置範例，包含了三個階段：test、build 和 deploy。\nstages: - test - build - deploy test: stage: test script: # 定義 test 階段的指令 - echo \u0026#34;Running tests\u0026#34; # 執行單元測試、程式碼品質檢查等 - npm test - npm run lint build: stage: build script: # 定義 build 階段的指令 - echo \u0026#34;Building the application\u0026#34; - docker build -t $IMAGE_NAME:$TAG . # 只有當測試通過後才執行 build needs: [\u0026#34;test\u0026#34;] deploy: stage: deploy script: # 定義 deploy 階段的指令 - echo \u0026#34;Deploying to production\u0026#34; # 在實際情況下，這裡可以是部署到 Kubernetes、AWS、GCP 等的相應指令 # 也可以使用 Helm 進行部署 # 只有當 build 成功後才執行 deploy needs: [\u0026#34;build\u0026#34;] 進階配置 # 在生產環境中，通常需要更複雜的配置，例如：配置環境變數、建構 mysql 資料庫、redis 等服務。\nstages: - test - build - deploy test: stage: test services: - name: mysql:5.7 alias: db - redis:latest alias: redis variables: MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} MYSQL_DATABASE: ${MYSQL_DATABASE} REDIS_PASSWORD: ${REDIS_PASSWORD} script: - echo \u0026#34;Running tests\u0026#34; - npm test - npm run lint build: stage: build script: - echo \u0026#34;Building the application\u0026#34; - docker build -t $IMAGE_NAME:$TAG . needs: [\u0026#34;test\u0026#34;] deploy: stage: deploy script: - echo \u0026#34;Deploying to production\u0026#34; needs: [\u0026#34;build\u0026#34;] parallel:matrix # ⚠️ 對於 runner 的配置，必須要有多台 runner 或者配置單台 runner 配置支援同時執行多個任務。\n⚠️ 矩陣的排列數不能超過 200\nparallel 可以在單一的 pipeline 中同時執行多個任務，這對於需要在多個環境或配置下運行相同任務的情況非常有用。\n如果需要在不同的 Node.js 版本和環境下運行測試，可以使用 parallel:matrix 來定義一個矩陣，這樣可以在不同的配置下同時運行相同的任務。\ntest: stage: test script: - echo \u0026#34;Running tests\u0026#34; parallel: matrix: - NODE_VERSION: [10, 12, 14] - ENV: [development, production] 參考 # Parallel ","date":"22 September 2023","externalUrl":null,"permalink":"/posts/gitlab/cicd/","section":"Posts","summary":"介紹 # GitLab 是一個開源的 DevOps 平台，提供了版本控制、CI/CD、代碼審查等功能。它的 CI/CD 功能可以幫助開發者自動化軟體開發流程，提高開發效率和質量。","title":"GitLab CICD","type":"posts"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/tags/cni/","section":"Tags","summary":"","title":"cni","type":"tags"},{"content":" 前言 # 最近在協助公司專案轉雲端架構時，由於服務只能啟用一個 pod 提供線上服務的運作，因此也選擇使用 statefulSet 部署服務，在這過程中發現的問題。\n事件流程 # RD 同仁更新了 code 到 gitLab，並沒有順利的完成 CICD。原因是 statefulSet pod 在關閉時，停留在 terminating，雖然 k8s 有 terminationGracePeriodSeconds，但由於情況特殊。當下的 terminationGracePeriodSeconds 是 14400，長達四小時。\n因線上緊急的問題，所以針對 terminating pod 採取了 kubectl delete pod [pod name] --grace-period=0 --force。之後重新建立的 pod 就會出現以下的錯誤訊息 👇\ncontainer veth name provided (eth0) already exists Google Support # 其實前陣子已經有錯誤影響到開發跟測試環境了，由於這次影響到正式環境。把案件單等級提升至 P1 並請 google 協助查找錯誤發生的原因。\n這次會發生的上述錯誤的原因，經過 google 協助主要是推測在 pod 進入關閉流程時，由於 terminationGracePeriodSeconds 設置時長有四小時，尚處於 pod 的 lifecycle 這時候，使用 kubectl delete pod --force 會導致隨然 pod 消失了，但有 container 設定殘留在 node 上，如果此時新的 pod 重新在同一顆 node 上面啟動就會造成有相同設定。\n雖然改成 deployment 可以規避，但相對的會浪費一組 IP，長久下來一樣會有問題。最重要的還是要讓 pod 結束整個 lifecycle 才不會產生後續的問題。\n","date":"17 September 2023","externalUrl":null,"permalink":"/journals/k8s/veth-name-provided-already-exists/","section":"Journals","summary":"前言 # 最近在協助公司專案轉雲端架構時，由於服務只能啟用一個 pod 提供線上服務的運作，因此也選擇使用 statefulSet 部署服務，在這過程中發現的問題。","title":"container veth name provided (eth0) already exists 故障排除","type":"journals"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/journals/","section":"Journals","summary":"","title":"Journals","type":"journals"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/tags/node/","section":"Tags","summary":"","title":"node","type":"tags"},{"content":"","date":"17 September 2023","externalUrl":null,"permalink":"/tags/pod/","section":"Tags","summary":"","title":"pod","type":"tags"},{"content":"","date":"27 August 2023","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"docker","type":"tags"},{"content":" Dockerfile # Dockerfile 是 Docker 的核心組件之一，用來定義如何建構一個 Docker 映像檔（image）。它是一個文本文件，包含了一系列的指令和參數，這些指令告訴 Docker 如何從基礎映像開始，安裝必要的軟體、配置環境變數、複製檔案等。\n可以保證每次使用相同的 Dockerfile 建構出來的映像檔都是一致的，這對於部署和維護應用程式非常重要。\n這裡要注意 EXPOSE，它用來告訴 Docker 哪些端口需要暴露給外部訪問。但是還是必須要在 docker run 時使用 -p 選項來實際映射端口。\n# 基礎映像，這裡使用 Alpine Linux，如果沒有指定 tag，則默認使用 latest FROM alpine # 設定作者資訊 LABEL maintainer=\u0026#34;bing-wei\u0026#34; # 設定工作目錄 WORKDIR /app # 複製當前目錄下的所有檔案到容器的 /app 目錄 COPY . . # 安裝必要的套件 RUN apk add --no-cache python3 py3-pip # 安裝 Python 相依套件 RUN pip3 install -r requirements.txt # 設定環境變數 ENV PYTHONUNBUFFERED=1 # 暴露容器的 8000 端口 EXPOSE 8000 # 設定容器啟動時執行的命令 CMD [\u0026#34;python3\u0026#34;, \u0026#34;app.py\u0026#34;] 多階段建構 # 在實際的生產環境中，通常會使用多階段建構（multi-stage builds）來減少最終映像檔的大小，這樣可以在開發階段安裝所有必要的工具和依賴，但在最終映像檔中只保留運行應用程式所需的部分。\n# 第一階段：建構階段 FROM node:14 AS build WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build # 第二階段：運行階段 FROM nginx:alpine COPY --from=build /app/dist /usr/share/nginx/html EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] 安全性考量 # 在撰寫 Dockerfile 時，還需要考慮安全性問題，例如：\n使用官方的基礎映像，這樣可以減少安全漏洞的風險。 避免使用 latest 標籤，因為這樣會導致映像檔在不同時間點可能有不同的內容，應該使用具體的版本號。 建立帳號和設定權限，避免使用 root 帳號運行應用程式。 # 使用官方的 Node.js 映像 FROM node:14 # 建立一個非 root 使用者 RUN useradd -m appuser # 切換到非 root 使用者 USER appuser # 設定工作目錄 WORKDIR /home/appuser/app # 複製 package.json 和 package-lock.json COPY package*.json ./ # 安裝相依套件 RUN npm install --only=production # 複製應用程式檔案 COPY --chown=appuser:appuser . . # 暴露應用程式端口 EXPOSE 3000 # 設定容器啟動命令 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] ","date":"27 August 2023","externalUrl":null,"permalink":"/posts/dockerfile/","section":"Posts","summary":"Dockerfile # Dockerfile 是 Docker 的核心組件之一，用來定義如何建構一個 Docker 映像檔（image）。它是一個文本文件，包含了一系列的指令和參數，這些指令告訴 Docker 如何從基礎映像開始，安裝必要的軟體、配置環境變數、複製檔案等。","title":"Dockerfile","type":"posts"},{"content":"","date":"19 August 2023","externalUrl":null,"permalink":"/tags/ingress/","section":"Tags","summary":"","title":"ingress","type":"tags"},{"content":" 前言 # 隨著系統架構可能日益龐大，可能會使用複數的 ingress 來做進入服務的區分。以防止在 ingress 異常的時候，會影響全體的服務使用。缺點是複數的 ingress 需要使用靜態 IP。在 GCP 的服務上，每保留一組靜態 IP 服務就是增加成本。接著會介紹 ingress controller 這項服務用於管理所有的 ingress。\n上一篇文章中有提到 ingress，如果想瞭解 ingress 可以先參考或預習這篇文章。 Ingress 6 August 2023\u0026middot;1 分鐘 k8s ingress Nginx Ingress Controller # 這篇文章要講解的 Nginx Ingress Controller 結合了 Ingress 的簡潔並支援 Nginx 相關的擴充功能，讓我們能更好的管理所有的 ingress，下面會簡單提到 nginx 以及 ingress 優點。\nNginx 介紹 # nginx 是一款高效能、耐用、且功能強大的 loadBalance 及 webServer。也擁有很高的市佔率。\n高效能的 webServer 遠勝傳統 apache server 的資源與效能 大量的模組與擴充功能 充足的安全性功能 輕量 容易水平擴展 Ingress 介紹 # 定義外部到內部的設定。\nService 連接 LoadBalance 設定 SSL/TLS 終端 虛擬主機設定 安裝 # 使用 Helm 來安裝 Ingress Controller helm upgrade --install ingress-nginx ingress-nginx \\ --repo https://kubernetes.github.io/ingress-nginx \\ --namespace ingress-nginx --create-namespace values # 使用 Helm 進行安裝，需要做調整，並想要參考有哪些值是可提供使用者調整。可以使用下列的指令輸出 values.yaml。\n或者到 Github 上閱讀整個服務的是如何運作跟建立的\nhelm show values ingress-nginx --repo https://kubernetes.github.io/ingress-nginx ","date":"19 August 2023","externalUrl":null,"permalink":"/posts/k8s/ingress-controller/","section":"Posts","summary":"前言 # 隨著系統架構可能日益龐大，可能會使用複數的 ingress 來做進入服務的區分。以防止在 ingress 異常的時候，會影響全體的服務使用。缺點是複數的 ingress 需要使用靜態 IP。在 GCP 的服務上，每保留一組靜態 IP 服務就是增加成本。接著會介紹 ingress controller 這項服務用於管理所有的 ingress。","title":"Ingress Controller 簡介","type":"posts"},{"content":" 介紹 ingress # ingress 是 k8s 給 service 提供外部訪問的 URL、SSL、路由等功能。 可以理解為 nginx 或 traefik 等的代理工具。允許透過某個 URL 進入對應的 service，且碰到某些 route 能夠 proxy pass 到其他 service。\n⭐ ingress 又分成外部負載平衡、內部負載平衡。兩者在使用設定上有一些小小的不同。\n外部負載平衡 # 通常對外部的負載平衡入口，都會設置防火牆或是白名單管理但是 k8s ingress 卻不能直接實現。需要透過一些 gcp 元件功能，來設置防火牆或白名單管理。\ncloud armor # armor 的翻譯是指盔甲的意思，這是由 gcp 提供的服務，具有分散式阻斷攻擊(DDos)防護機制、網路應用程式防火牆。可以搭配 loadBalance、Cloud CDN 來強化網路安全服務。\n那麼我們要如何將 cloud armor 應用在我們 ingress 上面呢？接著看下去 😎\n首先我們可以先找官方的使用手冊 Configuring Ingress using the default controller 接著將重點放在 backendConfig 設定上面，前面的介紹已經知道 ingress 負責依據路由規則代理轉發。文件上 backenConfig 與 service 可以耦合。使用 backendConfig 的設定。\nBackendConfig and FrontendConfig overview 詳細想知道 backendConfig 設定範例可以在文件連接內找到 👉 Configuring Ingress features through BackendConfig parameters 接著下面繪製一張外部負載平衡的架構圖。可以看到下圖中 114.1.46.157 的客戶端在訪問的時候被 ingress 給擋下了。\n原因是 ingress 後端 service 有耦合 backendConfig，透過 backendConfig 使用了 cloud armor。\nflowchart LR cli1(client 34.41.26.173) cli2(client 114.1.46.157) cli1 --\u003e ing cli2 --x ing subgraph k8s-cluster ing((ingress)) svc-web(web-service) svc-api(api-service) df-backend(backend-config) armor{{cloud-armor}} ing --\u003e svc-web ing --\u003e svc-api armor -.- df-backend df-backend -.-\u003e svc-web df-backend -.-\u003e svc-api end 內部負載平衡 # 講完了外部負載平衡，接著講 ingress 擔任內部負載平衡時，需要注意的事項。\nNetwork endpoint group # 什麼是 NEG ?\nNEG 是指 Network endpoint group，是一種配置。意思是指定一組後端 endpoint 或 service，借助NEG，Google Cloud 負載均衡器可以為基於 GCE 的工作負載、無服務器工作負載和容器化工作負載提供服務。可以更精細的將流量分配到負載均衡器的後端。\n使用時，對後端的 service 必須要使用 NEG，詳細想要了解可以參考 👉 Network endpoint groups overview ","date":"6 August 2023","externalUrl":null,"permalink":"/posts/k8s/ingress/","section":"Posts","summary":"介紹 ingress # ingress 是 k8s 給 service 提供外部訪問的 URL、SSL、路由等功能。 可以理解為 nginx 或 traefik 等的代理工具。允許透過某個 URL 進入對應的 service，且碰到某些 route 能夠 proxy pass 到其他 service。","title":"Ingress","type":"posts"},{"content":" 匯出/匯入 # export 和 save 都是用來匯出 docker 的映像檔，但是有些不同之處：\nexport 可以匯出在容器中已變更的設定，例如安裝的軟體或修改的配置檔案。 save 單純匯出映像檔，不包含在容器中已變更的設定。 在使用上要注意，如果映像檔使用 export 匯出，則需要使用 import 匯入；如果使用 save 匯出，則需要使用 load 匯入。\ndocker export image \u0026gt; filename.tar docker import \u0026lt; filename.tar docker save image \u0026gt; filename.tar docker load \u0026lt; filename.tar 與容器進行交互 # 通常我們會使用 docker run 指令來啟動容器，如果需要與容器進行交互，可以使用以下選項：\ndocker run -it image /bin/bash 如果要退出容器，可以使用 exit 或 ctrl+d。\n查看容器 # 如果要查看正在運行的容器，可以使用以下指令 docker ps，如果要查看所有的容器（包括已停止的容器），可以使用 docker ps -a。\ndocker ps -a 查看容器內的標準輸出 # 如果要查看容器內的標準輸出，可以使用 docker logs ，但是通常我們會持續的觀察容器的標準輸出，因此可以使用 -f 選項來持續查看。\ndocker logs -f container 查看容器啟動進程 # docker top container 容器資源使用狀況 # docker stats 清理技巧 # ⭐ prune操作是批量刪除類的危險操作，使用 y 確認。不想要輸入可以添加 -f，慎用!\n清除所有停止運行的容器 # docker container prune 清理未使用的映像檔 # docker image prune 清理所有無用的卷 # docker volume prune 參考 # 清理 Docker 的 container，image 與 volume ","date":"30 July 2023","externalUrl":null,"permalink":"/posts/docker/","section":"Posts","summary":"匯出/匯入 # export 和 save 都是用來匯出 docker 的映像檔，但是有些不同之處：","title":"Docker","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]